<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Reporte de Criptomonedas v1.1.5</title>
    <style>
        body {
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin-bottom: 20px;
        }
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
            background-color: #fff;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: center;
            cursor: pointer;
        }
        th {
            background-color: #f2f2f2;
            position: sticky;
            top: 0;
            z-index: 1;
            font-weight: 600;
        }
        tbody tr:nth-child(odd) {
            background-color: #f9f9f9;
        }
        tbody tr:hover {
            background-color: #f1f1f1;
        }
        @media (max-width: 768px) {
            table {
                display: block;
                overflow-x: auto;
                white-space: nowrap;
            }
            th, td {
                min-width: 100px;
                padding: 8px;
            }
        }
        th:nth-child(1), td:nth-child(1) { width: 10%; }
        th:nth-child(2), td:nth-child(2) { width: 10%; }
        th:nth-child(3), td:nth-child(3) { width: 10%; }
        th:nth-child(4), td:nth-child(4) { width: 10%; }
        th:nth-child(5), td:nth-child(5) { width: 10%; }
        th:nth-child(6), td:nth-child(6) { width: 10%; }
        th:nth-child(7), td:nth-child(7) { width: 10%; }
        th:nth-child(8), td:nth-child(8) { width: 10%; }
        th:nth-child(9), td:nth-child(9) { width: 10%; }
        #cargandoDatos {
            font-weight: bold;
            color: red;
            display: none;
        }
        #errorMessage {
            font-weight: bold;
            color: red;
            display: none;
        }
        fieldset {
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 10px;
        }
        fieldset.actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .header-info {
            padding: 10px;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .user-info {
            display: flex;
            gap: 20px;
            font-size: 0.9em;
            color: #666;
        }
        .user-info p {
            margin: 5px 0;
        }
        #resultados {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        #dataTable {
            width: 100%;
        }
        #progresoPorcentual, #totalPares {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="header-info">
        <h1 id="tituloReporte">Reporte de Criptomonedas v1.1.5</h1>
        <div class="user-info">
            <p>Usuario: <span id="currentUser"></span></p>
            <p>Fecha y Hora (UTC): <span id="currentDateTime"></span></p>
        </div>
    </div>
    <p id="cargandoDatos">Cargando datos...</p>
    <div id="errorMessage" style="display:none;color:red;font-weight:bold;"></div>
    <form class="selector" id="consultaForm">
        <fieldset>
            <legend>Búsqueda y Selección de Mercado</legend>
            <input type="text" id="filtro" placeholder="Filtrar..." autocomplete="off">
            <label for="marketSelect">Mercado:</label>
            <select id="marketSelect">
                <option value="spot">Spot</option>
                <option value="futures">Futuros</option>
            </select>
        </fieldset>
        <fieldset>
            <legend>Selección de Par</legend>
            <select id="parSelect"></select>
        </fieldset>
        <fieldset>
            <legend>Tipo de Consulta</legend>
            <select id="actionSelect">
                <option value="price">Precio actual</option>
                <option value="candles">Velas históricas</option>
                <option value="marketData">Datos de mercado</option>
                <option value="openInterest">Interés abierto</option>
            </select>
        </fieldset>
        <fieldset>
            <legend>Parámetros adicionales</legend>
            <div id="intervalContainer" style="display:none;">
                <label for="intervalSelect">Intervalo:</label>
                <select id="intervalSelect">
                    <option value="1m">1 minuto</option>
                    <option value="3m">3 minutos</option>
                    <option value="5m">5 minutos</option>
                    <option value="15m">15 minutos</option>
                    <option value="30m">30 minutos</option>
                    <option value="1h" selected>1 hora</option>
                    <option value="2h">2 horas</option>
                    <option value="4h">4 horas</option>
                    <option value="6h">6 horas</option>
                    <option value="8h">8 horas</option>
                    <option value="12h">12 horas</option>
                    <option value="1d">1 día</option>
                    <option value="3d">3 días</option>
                    <option value="1w">1 semana</option>
                    <option value="1M">1 mes</option>
                </select>
            </div>
        </fieldset>
        <fieldset class="actions">
            <legend>Acciones</legend>
            <button type="submit">Consultar</button>
            <button type="button" id="buscarMaximos" style="display:none;">Buscar Pares en Máximos</button>
            <button type="button" id="exportarCSV">Exportar CSV</button>
            <button type="button" id="calcularResumen" style="display:none;">Simulación Monte Carlo</button>
            <button type="button" id="toggleTabla" style="display:none;">Ver tabla de velas</button>
        </fieldset>
    </form>
    <div id="resultados">
        <p id="progresoPorcentual">0%</p>
        <p id="totalPares">Total de pares procesados: 0, Total de pares válidos: 0</p>
        <table id="dataTable">
            <thead>
                <tr>
                    <th>Par</th>
                    <th>Precio de Apertura</th>
                    <th>Precio Máximo</th>
                    <th>Precio Mínimo</th>
                    <th>Precio de Cierre</th>
                    <th>Volumen</th>
                    <th>Número de Operaciones</th>
                    <th>Variación Porcentual</th>
                    <th>Timestamp</th>
                    <th>Orden</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
    <div id="resumenContainer" style="display:none; padding:10px; background:#f0f0f0; margin-top:20px;">
        <div id="resumen"></div>
    </div>
    <script>
        const VERSION = '1.1.5';
        // CHANGELOG v1.1.5 (2025-11-05): Aplicado un lookback fijo de 480 velas para el cálculo de todas las métricas y la deriva histórica (mu y sigma) en la Simulación Monte Carlo, resolviendo el conflicto de horizontes temporales.
        // CHANGELOG v1.1.4 (2025-11-05): Implementación del Método Box-Muller para distribución normal en Monte Carlo. El sesgo 'bias' se añade al drift 'mu_adj'. Se corrigió el orden de definición de la variable 'bias' para evitar errores de ejecución.
        // CHANGELOG v1.1.3 (2025-08-02): Modificado cálculo de puntos de entrada para usar el timeframe actual en lugar de datos diarios fijos.
        // Los puntos de entrada ahora se calculan con los mismos datos mostrados en la tabla.
        let currentUser = 'gustavojavier7';
        let currentDateTime = new Date().toISOString().replace('T', ' ').slice(0, 19);
        const API_ENDPOINTS = {
            SPOT: {
                EXCHANGE_INFO: 'https://data-api.binance.vision/api/v3/exchangeInfo',
                TICKER: 'https://data-api.binance.vision/api/v3/ticker/bookTicker',
                MARKET: 'https://api.binance.com/api/v3/ticker/24hr',
                KLINES: 'https://data-api.binance.vision/api/v3/klines'
            },
            FUTURES: {
                EXCHANGE_INFO: 'https://fapi.binance.com/fapi/v1/exchangeInfo',
                TICKER: 'https://fapi.binance.com/fapi/v1/ticker/bookTicker',
                MARKET: 'https://fapi.binance.com/fapi/v1/ticker/24hr',
                KLINES: 'https://fapi.binance.com/fapi/v1/klines',
                OPEN_INTEREST: 'https://fapi.binance.com/fapi/v1/openInterest',
                OPEN_INTEREST_HISTORY: 'https://fapi.binance.com/futures/data/openInterestHist'
            }
        };
        function getApiUrl(market, action, pair, interval, limit = 1000) {
            switch(action) {
                case 'marketData':
                    return market === 'spot' ? API_ENDPOINTS.SPOT.MARKET : API_ENDPOINTS.FUTURES.MARKET;
                case 'price':
                    return market === 'spot'
                        ? `${API_ENDPOINTS.SPOT.TICKER}?symbol=${pair}`
                        : `${API_ENDPOINTS.FUTURES.TICKER}?symbol=${pair}`;
                case 'candles':
                    const base = market === 'spot' ? API_ENDPOINTS.SPOT.KLINES : API_ENDPOINTS.FUTURES.KLINES;
                    return `${base}?symbol=${pair}&interval=${interval}&limit=${limit}`;
                case 'openInterest':
                    return `${API_ENDPOINTS.FUTURES.OPEN_INTEREST}?symbol=${pair}`;
                default:
                    throw new Error('Tipo de acción no válida');
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            const filtroInput = document.getElementById('filtro');
            const marketSelect = document.getElementById('marketSelect');
            const parSelect = document.getElementById('parSelect');
            const actionSelect = document.getElementById('actionSelect');
            const intervalSelect = document.getElementById('intervalSelect');
            const intervalContainer = document.getElementById('intervalContainer');
            const consultaForm = document.getElementById('consultaForm');
            const dataTable = document.getElementById('dataTable').getElementsByTagName('tbody')[0];
            const cargandoDatos = document.getElementById('cargandoDatos');
            const errorMessage = document.getElementById('errorMessage');
            const tituloReporte = document.getElementById('tituloReporte');
            const progresoPorcentual = document.getElementById('progresoPorcentual');
            const totalPares = document.getElementById('totalPares');
            const resultadosDiv = document.getElementById('resultados');
            const buscarMaximosButton = document.getElementById('buscarMaximos');
            const exportarCSVButton = document.getElementById('exportarCSV');
            const calcularResumenButton = document.getElementById('calcularResumen');
            const toggleTablaButton = document.getElementById('toggleTabla');
            const resumenDiv = document.getElementById('resumenContainer');
            let spotPares = [];
            let futurosPares = [];
            let sortOrder = 1;
            let sortColumn = null;
            let isMaximosMode = false;
            let datosRaw = []; // Variable global para almacenar datos de velas
            let currentTimeframe = '1h'; // Variable para almacenar el timeframe actual
            const lastPrices = {};
            const lastColors = {};

            function randomStandardNormal() {
                let u1 = 0;
                let u2 = 0;
                // Asegurar que los valores no sean 0 para evitar log(0)
                while (u1 === 0) u1 = Math.random();
                while (u2 === 0) u2 = Math.random();
                return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            }

            function actualizarColorPrecio(cell, key, nuevoPrecio) {
                const precioAnterior = lastPrices[key];
                if (precioAnterior !== undefined) {
                    if (nuevoPrecio > precioAnterior) {
                        cell.style.color = 'green';
                        lastColors[key] = 'green';
                    } else if (nuevoPrecio < precioAnterior) {
                        cell.style.color = 'red';
                        lastColors[key] = 'red';
                    } else {
                        cell.style.color = lastColors[key] || '';
                    }
                } else {
                    cell.style.color = lastColors[key] || '';
                }
                lastPrices[key] = nuevoPrecio;
            }
            document.getElementById('currentUser').textContent = currentUser;
            document.getElementById('currentDateTime').textContent = currentDateTime;
            function mostrarCargando() {
                cargandoDatos.style.display = 'block';
                errorMessage.style.display = 'none';
            }
            function ocultarCargando() {
                cargandoDatos.style.display = 'none';
            }
            function mostrarError(mensaje) {
                errorMessage.textContent = mensaje;
                errorMessage.style.display = 'block';
                ocultarCargando();
            }
            function generarCodigoUnico() {
                const ahora = new Date();
                const timestamp = ahora.getTime();
                const codigo = timestamp.toString().padStart(16, '0');
                return `${codigo.slice(0, 4)}-${codigo.slice(4, 8)}-${codigo.slice(8, 12)}-${codigo.slice(12, 16)}`;
            }
            function formatearTituloReporte(tipoReporte, par, timeframe, codigoUnico, action = '') {
                let titulo;
                if (action === 'candles') {
                    titulo = `${par}${timeframe ? `_${timeframe}` : ''}_${codigoUnico}`;
                } else {
                    titulo = `${tipoReporte}`;
                    if (par && action !== 'marketData') titulo += `+${par}`;
                    if (timeframe && action === 'candles') titulo += `+${timeframe}`;
                    if (codigoUnico) titulo += `+${codigoUnico}`;
                    titulo += `+${currentUser}`;
                }
                return titulo.replace(/ /g, '_');
            }
            function actualizarTitulo(tipoReporte, par, timeframe, codigoUnico, action) {
                const nuevoTitulo = formatearTituloReporte(tipoReporte, par, timeframe, codigoUnico, action);
                document.getElementById('tituloReporte').textContent = nuevoTitulo;
                document.title = nuevoTitulo;
            }
            consultaForm.addEventListener('submit', async (event) => {
                event.preventDefault();
                const nuevoCodigoUnico = generarCodigoUnico();
                currentDateTime = new Date().toISOString().replace('T', ' ').slice(0, 19);
                document.getElementById('currentDateTime').textContent = currentDateTime;
                // Reset visual state
                resumenDiv.style.display = 'none';
                resumenDiv.innerHTML = '';
                resultadosDiv.style.display = 'block';
                toggleTablaButton.style.display = 'none';
                toggleTablaButton.textContent = 'Ver tabla de velas';
                mostrarCargando();
                dataTable.innerHTML = '';
                isMaximosMode = false;
                let par = parSelect.value;
                const action = actionSelect.value;
                const intervalo = intervalSelect.value;
                
                // Actualizar el timeframe actual
                currentTimeframe = intervalo;
                
                try {
                    const tipoReporte = determinarTipoReporte(action);
                    const datos = await realizarConsulta(par, action, intervalo);
                    procesarDatos(datos, action, par);
                    actualizarTitulo(tipoReporte, par, intervalo, nuevoCodigoUnico, action);
                    ocultarCargando();
                    calcularResumenButton.style.display = action === 'candles' ? 'inline-block' : 'none';
                    toggleTablaButton.style.display = 'none';
                    resultadosDiv.style.display = 'block';
                } catch (error) {
                    console.error('Error en la consulta:', error);
                    mostrarError(`Error: ${error.message}`);
                }
            });
            function determinarTipoReporte(action) {
                switch(action) {
                    case 'candles':
                        return 'Velas';
                    case 'price':
                        return 'Precios';
                    case 'marketData':
                        return 'Datos de Mercado';
                    case 'openInterest':
                        return 'Interés Abierto';
                    default:
                        return 'Reporte';
                }
            }
            function procesarDatos(datos, action, par) {
                dataTable.innerHTML = '';
                let total = Array.isArray(datos) ? datos.length : 1;
                let progreso = 0;
                let paresProcesados = 0;
                let paresValidosCount = 0;
                actualizarEncabezados(action);
                if (action === 'marketData') {
                    if (!Array.isArray(datos)) datos = [datos];
                    datos.forEach((dato, index) => {
                        if (spotPares.includes(dato.symbol) || futurosPares.includes(dato.symbol)) {
                            paresProcesados++;
                            paresValidosCount++;
                            progreso = Math.min(100, Math.round(((index + 1) / total) * 100));
                            const row = dataTable.insertRow();
                              row.innerHTML = `
                                <td>${dato.symbol}</td>
                                <td>${parseFloat(dato.openPrice).toFixed(8)}</td>
                                <td>${parseFloat(dato.highPrice).toFixed(8)}</td>
                                <td>${parseFloat(dato.lowPrice).toFixed(8)}</td>
                                <td>${parseFloat(dato.lastPrice).toFixed(8)}</td>
                                <td>${parseFloat(dato.volume).toFixed(8)}</td>
                                <td>${dato.count}</td>
                                <td>${parseFloat(dato.priceChangePercent).toFixed(8)}%</td>
                                <td>${formatearFecha(dato.closeTime)}</td>
                                <td>${index + 1}</td>
                              `;
                              const priceCell = row.cells[4];
                              actualizarColorPrecio(priceCell, dato.symbol, parseFloat(dato.lastPrice));
                          }
                          progresoPorcentual.textContent = `${progreso}%`;
                          totalPares.textContent = `Total de pares procesados: ${paresProcesados}, Total de pares válidos: ${paresValidosCount}`;
                      });
                  } else if (action === 'price') {
                      const row = dataTable.insertRow();
                      row.innerHTML = `
                          <td>${datos.symbol}</td>
                          <td>${parseFloat(datos.bidPrice).toFixed(8)}</td>
                          <td>${parseFloat(datos.askPrice).toFixed(8)}</td>
                      `;
                      actualizarColorPrecio(row.cells[1], `${datos.symbol}-bid`, parseFloat(datos.bidPrice));
                      actualizarColorPrecio(row.cells[2], `${datos.symbol}-ask`, parseFloat(datos.askPrice));
                      progresoPorcentual.textContent = '100%';
                      totalPares.textContent = `Total de pares procesados: 1, Total de pares válidos: 1`;
                  } else if (action === 'candles') {
                    datosRaw = datos.slice(); // Mantener orden original (antiguo -> reciente) para análisis
                    const datosTabla = datosRaw.slice().reverse();
                    datosTabla.forEach((vela, index) => {
                        paresProcesados++;
                        paresValidosCount++;
                        progreso = Math.min(100, Math.round(((index + 1) / total) * 100));
                        const precioApertura = parseFloat(vela[1]);
                        const precioCierre = parseFloat(vela[4]);
                        const variacionPorcentual = ((precioCierre - precioApertura) / precioApertura) * 100;
                        const row = dataTable.insertRow();
                        row.innerHTML = `
                            <td>${par}</td>
                            <td>${precioApertura.toFixed(8)}</td>
                            <td>${parseFloat(vela[2]).toFixed(8)}</td>
                            <td>${parseFloat(vela[3]).toFixed(8)}</td>
                            <td>${precioCierre.toFixed(8)}</td>
                            <td>${parseFloat(vela[5]).toFixed(8)}</td>
                            <td>${vela[8]}</td>
                            <td>${variacionPorcentual.toFixed(8)}%</td>
                            <td>${formatearFecha(vela[0])}</td>
                            <td>${index + 1}</td>
                        `;
                        progresoPorcentual.textContent = `${progreso}%`;
                        totalPares.textContent = `Total de pares procesados: ${paresProcesados}, Total de pares válidos: ${paresValidosCount}`;
                    });
                } else if (action === 'openInterest') {
                    const row = dataTable.insertRow();
                    row.innerHTML = `
                        <td>${datos.symbol}</td>
                        <td>${parseFloat(datos.openInterest).toFixed(8)}</td>
                        <td>${formatearFecha(datos.time)}</td>
                    `;
                    progresoPorcentual.textContent = '100%';
                    totalPares.textContent = `Total de pares procesados: 1, Total de pares válidos: 1`;
                }
            }
            async function realizarConsulta(par, action, intervalo) {
                let url;
                if (!par && action !== 'marketData') {
                    throw new Error('Debe seleccionar un par antes de consultar.');
                }
                if (par && marketSelect.value === 'spot' && !spotPares.includes(par)) {
                    throw new Error('El par seleccionado no está disponible en el mercado SPOT.');
                }
                if (par && marketSelect.value === 'futures' && !futurosPares.includes(par)) {
                    throw new Error('El par seleccionado no está disponible en el mercado de Futuros perpetuos.');
                }
                url = getApiUrl(marketSelect.value, action, par, intervalo);
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('Error al conectar con la API');
                }
                return await response.json();
            }
            function actualizarEncabezados(action) {
                const thead = document.getElementById('dataTable').getElementsByTagName('thead')[0];
                thead.innerHTML = '';
                const row = thead.insertRow();
                const crearEncabezado = (texto, index) => {
                    return `<th onclick="sortTable(${index})">${texto} <span class="sort-icon" data-column="${index}">▴▾</span></th>`;
                };
                if (action === 'marketData') {
                    row.innerHTML = `
                        ${crearEncabezado('Par', 0)}
                        ${crearEncabezado('Precio de Apertura', 1)}
                        ${crearEncabezado('Precio Máximo', 2)}
                        ${crearEncabezado('Precio Mínimo', 3)}
                        ${crearEncabezado('Precio de Cierre', 4)}
                        ${crearEncabezado('Volumen', 5)}
                        ${crearEncabezado('Número de Operaciones', 6)}
                        ${crearEncabezado('Variación Porcentual', 7)}
                        ${crearEncabezado('Timestamp', 8)}
                        ${crearEncabezado('Orden', 9)}
                    `;
                } else if (action === 'price') {
                    row.innerHTML = `
                        ${crearEncabezado('Par', 0)}
                        ${crearEncabezado('Precio de Compra', 1)}
                        ${crearEncabezado('Precio de Venta', 2)}
                    `;
                } else if (action === 'candles') {
                    row.innerHTML = `
                        ${crearEncabezado('Par', 0)}
                        ${crearEncabezado('Precio de Apertura', 1)}
                        ${crearEncabezado('Precio Máximo', 2)}
                        ${crearEncabezado('Precio Mínimo', 3)}
                        ${crearEncabezado('Precio de Cierre', 4)}
                        ${crearEncabezado('Volumen', 5)}
                        ${crearEncabezado('Número de Operaciones', 6)}
                        ${crearEncabezado('Variación Porcentual', 7)}
                        ${crearEncabezado('Timestamp', 8)}
                        ${crearEncabezado('Orden', 9)}
                    `;
                } else if (action === 'openInterest') {
                    row.innerHTML = `
                        ${crearEncabezado('Par', 0)}
                        ${crearEncabezado('Interés Abierto', 1)}
                        ${crearEncabezado('Timestamp', 2)}
                    `;
                }
            }
            function formatearFecha(timestamp) {
                const fecha = new Date(timestamp);
                const dia = String(fecha.getDate()).padStart(2, '0');
                const mes = String(fecha.getMonth() + 1).padStart(2, '0');
                const anio = fecha.getFullYear();
                const horas = String(fecha.getHours()).padStart(2, '0');
                const minutos = String(fecha.getMinutes()).padStart(2, '0');
                const segundos = String(fecha.getSeconds()).padStart(2, '0');
                return `${dia}-${mes}-${anio} ${horas}:${minutos}:${segundos}`;
            }
            function exportarTablaCSV() {
                const table = document.getElementById('dataTable');
                const rows = Array.from(table.querySelectorAll('tr'));
                let csvContent = '';
                rows.forEach((row, index) => {
                    const cells = Array.from(row.querySelectorAll('th, td'));
                    const rowData = cells.map(cell => {
                        let text = cell.textContent.trim();
                        if (index === 0) text = text.replace(' ▴▾', '');
                        return `"${text.replace(/"/g, '""')}"`;
                    }).join(',');
                    csvContent += rowData + '\n';
                });
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const tituloReporte = document.getElementById('tituloReporte').textContent.replace(/ /g, '_');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `${tituloReporte}.csv`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
            const codigoUnico = generarCodigoUnico();
            actualizarTitulo('Reporte', '', '', codigoUnico);
            mostrarCargando();
            Promise.all([
                fetch(API_ENDPOINTS.SPOT.EXCHANGE_INFO),
                fetch(API_ENDPOINTS.FUTURES.EXCHANGE_INFO)
            ])
            .then(responses => Promise.all(responses.map(response => {
                if (!response.ok) throw new Error('Error al conectar con la API');
                return response.json();
            })))
            .then(data => {
                spotPares = data[0].symbols.filter(symbol => symbol.status === 'TRADING').map(symbol => symbol.symbol);
                futurosPares = data[1].symbols.filter(symbol => symbol.status === 'TRADING' && symbol.contractType === 'PERPETUAL').map(symbol => symbol.symbol);
                actualizarListaPares();
                ocultarCargando();
            })
            .catch(error => {
                console.error('Error al obtener los pares disponibles:', error);
                mostrarError(`Error al conectar con la API: ${error.message}`);
            });
            filtroInput.addEventListener('input', () => {
                const filtro = filtroInput.value.toUpperCase();
                Array.from(parSelect.options).forEach(option => {
                    option.style.display = option.value.includes(filtro) ? 'block' : 'none';
                });
            });
            function actualizarListaPares() {
                parSelect.innerHTML = '';
                const pares = marketSelect.value === 'spot' ? spotPares : futurosPares;
                pares.forEach(par => {
                    const option = document.createElement('option');
                    option.value = par;
                    option.textContent = par;
                    parSelect.appendChild(option);
                });
            }
            marketSelect.addEventListener('change', () => {
                actualizarListaPares();
                filtroInput.dispatchEvent(new Event('input'));
                buscarMaximosButton.style.display = marketSelect.value === 'futures' && actionSelect.value === 'marketData' ? 'inline-block' : 'none';
            });
            actionSelect.addEventListener('change', () => {
                intervalContainer.style.display = actionSelect.value === 'candles' ? 'inline-block' : 'none';
                parSelect.disabled = actionSelect.value === 'marketData';
                if (actionSelect.value === 'openInterest') {
                    if (marketSelect.value !== 'futures') {
                        marketSelect.value = 'futures';
                        actualizarListaPares();
                    }
                    marketSelect.disabled = true;
                    mostrarError('El interés abierto solo está disponible para Futuros.');
                } else {
                    marketSelect.disabled = false;
                    errorMessage.style.display = 'none';
                }
                buscarMaximosButton.style.display = marketSelect.value === 'futures' && actionSelect.value === 'marketData' ? 'inline-block' : 'none';
            });
            actionSelect.dispatchEvent(new Event('change'));
            buscarMaximosButton.addEventListener('click', () => {
                const rows = Array.from(dataTable.getElementsByTagName('tr'));
                rows.sort((a, b) => {
                    const precioCierreA = parseFloat(a.getElementsByTagName('td')[4].textContent);
                    const precioMaximoA = parseFloat(a.getElementsByTagName('td')[2].textContent);
                    const precioCierreB = parseFloat(b.getElementsByTagName('td')[4].textContent);
                    const precioMaximoB = parseFloat(b.getElementsByTagName('td')[2].textContent);
                    const cercaniaA = (precioCierreA / precioMaximoA) * 100;
                    const cercaniaB = (precioCierreB / precioMaximoB) * 100;
                    return cercaniaB - cercaniaA;
                });
                rows.forEach(row => {
                    const precioCierre = parseFloat(row.getElementsByTagName('td')[4].textContent);
                    const precioMaximo = parseFloat(row.getElementsByTagName('td')[2].textContent);
                    const cercania = (precioCierre / precioMaximo) * 100;
                    row.getElementsByTagName('td')[7].textContent = `${cercania.toFixed(8)}%`;
                    dataTable.appendChild(row);
                });
                isMaximosMode = true;
                actualizarEncabezados(actionSelect.value);
            });
            window.sortTable = function(columnIndex) {
                const table = document.getElementById('dataTable');
                const tbody = table.getElementsByTagName('tbody')[0];
                const rows = Array.from(tbody.getElementsByTagName('tr'));
                if (sortColumn === columnIndex) {
                    sortOrder *= -1;
                } else {
                    sortColumn = columnIndex;
                    sortOrder = 1;
                }
                rows.sort((a, b) => {
                    const aText = a.getElementsByTagName('td')[columnIndex].textContent.trim();
                    const bText = b.getElementsByTagName('td')[columnIndex].textContent.trim();
                    return sortOrder * aText.localeCompare(bText, undefined, { numeric: true });
                });
                rows.forEach(row => tbody.appendChild(row));
            };
            exportarCSVButton.addEventListener('click', () => {
                if (dataTable.rows.length === 0) {
                    alert('No hay datos para exportar. Por favor, realiza una consulta primero.');
                    return;
                }
                exportarTablaCSV();
            });

            function calcularRSI(closes, periodo) {
                if (closes.length < periodo + 1) return 'N/A';
                let gains = 0, losses = 0;
                for (let i = 1; i <= periodo; i++) {
                    const diff = closes[i] - closes[i - 1];
                    if (diff > 0) gains += diff; else losses -= diff;
                }
                let avgGain = gains / periodo;
                let avgLoss = losses / periodo || 1;
                let rs = avgGain / avgLoss;
                let rsi = 100 - (100 / (1 + rs));
                for (let i = periodo + 1; i < closes.length; i++) {
                    const diff = closes[i] - closes[i - 1];
                    avgGain = (avgGain * (periodo - 1) + (diff > 0 ? diff : 0)) / periodo;
                    avgLoss = (avgLoss * (periodo - 1) + (diff < 0 ? -diff : 0)) / periodo;
                    rs = avgGain / avgLoss || 1;
                    rsi = 100 - (100 / (1 + rs));
                }
                return rsi.toFixed(2);
            }
            function calcularEMAserie(prices, period) {
                if (!Array.isArray(prices) || prices.length < period || period <= 0) return null;
                const emaArray = new Array(prices.length);
                let sum = 0;
                for (let i = 0; i < period; i++) sum += prices[i];
                emaArray[period - 1] = sum / period;
                const multiplier = 2 / (period + 1);
                for (let i = period; i < prices.length; i++) {
                    emaArray[i] = (prices[i] * multiplier) + (emaArray[i - 1] * (1 - multiplier));
                }
                return emaArray;
            }
            function calcularMACD(prices, periodo) {
                const shortPeriod = Math.round(periodo / 3);
                const longPeriod = Math.round(periodo / 1.5);
                const signalPeriod = Math.round(periodo / 4);
                if (prices.length < longPeriod + signalPeriod) return {macd: 'N/A', signal: 'N/A', histogram: 'N/A', params: ''};
                const emaShort = calcularEMAserie(prices, shortPeriod);
                const emaLong = calcularEMAserie(prices, longPeriod);
                if (!emaShort || !emaLong) return {macd: 'N/A', signal: 'N/A', histogram: 'N/A', params: ''};
                const macdLine = [];
                for (let i = longPeriod - 1; i < prices.length; i++) {
                    macdLine.push(emaShort[i] - emaLong[i]);
                }
                const signalLine = calcularEMAserie(macdLine, signalPeriod);
                if (!signalLine) return {macd: 'N/A', signal: 'N/A', histogram: 'N/A', params: ''};
                const histogram = [];
                for (let i = signalPeriod - 1; i < macdLine.length; i++) {
                    histogram.push(macdLine[i] - signalLine[i]);
                }
                return {
                    macd: macdLine[macdLine.length - 1].toFixed(8),
                    signal: signalLine[signalLine.length - 1].toFixed(8),
                    histogram: histogram[histogram.length - 1].toFixed(8),
                    params: `${shortPeriod}/${longPeriod}/${signalPeriod}`
                };
            }
            function calcularMomentoCentral(valores, orden) {
                if (!Array.isArray(valores) || valores.length === 0) return 0;
                const media = valores.reduce((s, v) => s + v, 0) / valores.length;
                return valores.reduce((s, v) => s + Math.pow(v - media, orden), 0) / valores.length;
            }
            function calcularDesviacionEstandar(valores) {
                if (!Array.isArray(valores) || valores.length < 2) return 0;
                const media = valores.reduce((s, v) => s + v, 0) / valores.length;
                const varianza = valores.reduce((s, v) => s + Math.pow(v - media, 2), 0) / (valores.length - 1);
                return Math.sqrt(varianza);
            }
            function calcularAsimetria(valores) {
                if (!Array.isArray(valores) || valores.length < 3) return 0;
                const desviacion = calcularDesviacionEstandar(valores);
                if (desviacion === 0) return 0;
                const momento3 = calcularMomentoCentral(valores, 3);
                return momento3 / Math.pow(desviacion, 3);
            }
            function calcularCurtosis(valores) {
                if (!Array.isArray(valores) || valores.length < 4) return 0;
                const desviacion = calcularDesviacionEstandar(valores);
                if (desviacion === 0) return 0;
                const momento4 = calcularMomentoCentral(valores, 4);
                const curtosisExceso = momento4 / Math.pow(desviacion, 4);
                return curtosisExceso - 3;
            }
            function calcularAutocorrelacion(valores, lag) {
                if (!Array.isArray(valores) || valores.length <= lag || lag < 1) return 0;
                const media = valores.reduce((s, v) => s + v, 0) / valores.length;
                let numerador = 0;
                let denominador = 0;
                for (let i = 0; i < valores.length; i++) {
                    const desviacion = valores[i] - media;
                    denominador += desviacion * desviacion;
                    if (i >= lag) {
                        numerador += desviacion * (valores[i - lag] - media);
                    }
                }
                if (denominador === 0) return 0;
                return numerador / denominador;
            }
            function calcularATR(highs, lows, closes, periodo) {
                if (highs.length < periodo + 1) return 'N/A';
                const trs = [];
                for (let i = 1; i < highs.length; i++) {
                    const tr = Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1]));
                    trs.push(tr);
                }
                let atr = trs.slice(0, periodo).reduce((sum, v) => sum + v, 0) / periodo;
                for (let i = periodo; i < trs.length; i++) {
                    atr = (atr * (periodo - 1) + trs[i]) / periodo;
                }
                return atr.toFixed(8);
            }
            function mostrarResumen(periodo) {
                const closes = datosRaw.map(v => parseFloat(v[4]));
                const highs = datosRaw.map(v => parseFloat(v[2]));
                const lows = datosRaw.map(v => parseFloat(v[3]));
                const rsi = calcularRSI(closes, periodo);
                const interpretacionRSI = rsi > 70 ? 'Sobrecompra' : rsi < 30 ? 'Sobrevenda' : 'Neutral';
                const emaSerie = calcularEMAserie(closes, periodo);
                const emaValor = emaSerie ? emaSerie[closes.length - 1] : null;
                const ema = emaValor !== null && emaValor !== undefined ? emaValor.toFixed(8) : 'N/A';
                const atr = calcularATR(highs, lows, closes, periodo);
                const macd = calcularMACD(closes, periodo);
                const precioMedio = closes.reduce((sum, p) => sum + p, 0) / closes.length;
                const atrValor = parseFloat(atr);
                const volatilidadRelativa = Number.isFinite(atrValor)
                    ? ((atrValor / precioMedio) * 100).toFixed(2) + '%'
                    : 'N/A';
                const ultimaVela = datosRaw[datosRaw.length - 1];
                const high = parseFloat(ultimaVela[2]);
                const low = parseFloat(ultimaVela[3]);
                const close = parseFloat(ultimaVela[4]);
                const pivot = (high + low + close) / 3;
                const r1 = (2 * pivot) - low;
                const r2 = pivot + (high - low);
                const s1 = (2 * pivot) - high;
                const s2 = pivot - (high - low);
                
                const html = `
                    <h2>Métricas (Periodo: ${periodo}) - Timeframe: ${currentTimeframe}</h2>
                    <p>RSI: ${rsi} (${interpretacionRSI})</p>
                    <p>EMA: ${ema}</p>
                    <p>ATR: ${atr}</p>
                    <p>Volatilidad Relativa: ${volatilidadRelativa}</p>
                    <p>MACD (Params: ${macd.params}): Line ${macd.macd} | Signal ${macd.signal} | Histogram ${macd.histogram}</p>
                    <p>Punto Pivote: ${pivot.toFixed(8)}</p>
                    <p>Resistencia 1: ${r1.toFixed(8)} | Resistencia 2: ${r2.toFixed(8)}</p>
                    <p>Soporte 1: ${s1.toFixed(8)} | Soporte 2: ${s2.toFixed(8)}</p>
                `;
                document.getElementById('resumen').innerHTML = html;
            }
            // --- Simulación Monte Carlo (ajustada a TF dinámico y 20 velas fijas) ---
            function simularMonteCarlo(datos, metrics) {
                if (!datos.length) {
                    throw new Error('No hay datos suficientes para la simulación.');
                }
                // Para calcular rendimientos mantenemos el orden cronológico (más antiguo -> más reciente)
                const precios = datos.slice().reverse().map(v => parseFloat(v[4]));
                const rendimientos = [];
                for (let i = 1; i < precios.length; i++) {
                    rendimientos.push(Math.log(precios[i] / precios[i - 1]));
                }

                const mu = rendimientos.reduce((a,b)=>a+b,0)/rendimientos.length;
                const sigma = Math.sqrt(rendimientos.reduce((a,b)=>a+Math.pow(b-mu,2),0)/(rendimientos.length-1));

                // Ajuste por métricas
                const fgap = (metrics["Pronóstico Lineal"] - metrics["EMA"]) / metrics["EMA"];
                
                // Se corrigió el orden: 'bias' debe definirse antes de 'mu_adj'
                const bias = (metrics["Prop Vol Taker Buy / Vol"] - 0.5) * 0.25; 
                
                const mu_adj = mu * (1 + 0.5*fgap + 0.2*metrics["Auto Correlación 24h"]) + bias * 0.5;
                const sigma_adj = sigma * (1 + 0.3*Math.abs(metrics["Asimetría Precios"]) + 0.2*Math.abs(metrics["Curtosis"]));
                

                // Ajuste del horizonte según TF
		        const steps = 20;
		        let tfMin = 3;
		        if (typeof currentTimeframe === 'string') {
		            const match = currentTimeframe.match(/(\d+)([mhdwM])/);
		            if (match) {
		                const n = parseInt(match[1]);
		                const u = match[2];
		                if (u === 'm') tfMin = n;
		                else if (u === 'h') tfMin = n * 60;
		                else if (u === 'd') tfMin = n * 1440;
		                else if (u === 'w') tfMin = n * 10080;
		                else if (u === 'M') tfMin = n * 43200;
		            }
		        }
		        const dtStep = tfMin / (60 * 24 * 365);
		        const driftTerm = (mu_adj - 0.5 * sigma_adj ** 2) * dtStep;
		        const diffusionTerm = sigma_adj * Math.sqrt(dtStep);

		        // Simulación: la vela más reciente está en datos[0]
		        const S0 = parseFloat(datos[0][4]);
                const nSim = 10000;
                const finales = [];
                for (let j = 0; j < nSim; j++) {
                    let S = S0;
		            for (let t = 0; t < steps; t++) {
		                const Z = randomStandardNormal();
		                S *= Math.exp(driftTerm + diffusionTerm * Z);
		            }
		            finales.push(S);
		        }

                finales.sort((a,b)=>a-b);
                const promedio = finales.reduce((a,b)=>a+b,0)/nSim;
                const p2_5 = finales[Math.floor(0.025*nSim)];
                const p97_5 = finales[Math.floor(0.975*nSim)];
                const subida = finales.filter(f=>f>S0).length/nSim*100;
                const bajada = 100-subida;
                const var95 = finales[Math.floor(0.05*nSim)]-S0;
		        const horizonteHoras = (tfMin*steps)/60;

                return {S0,promedio,subida,bajada,ic95:[p2_5,p97_5],var95,horizonteHoras};
            }
            calcularResumenButton.addEventListener('click', () => {
                if (datosRaw.length === 0) {
                    alert('No hay datos de velas para analizar.');
                    return;
                }

                // La tabla muestra datosRaw invertido. Asumimos que datosRaw está
                // ordenado del más antiguo al más reciente (Binance API).
                const LOOKBACK_SIZE = 480;
                // 1) Quedarnos con las últimas 480 velas disponibles
                const datosParaCalculoRecientes = datosRaw.slice(-LOOKBACK_SIZE);
                // 2) Invertir para que la vela más reciente esté en el índice 0
                const datosParaCalculo = datosParaCalculoRecientes.reverse();
                // Si hay menos de 20 velas (steps de la simulación), no se puede calcular.
                if (datosParaCalculo.length < 20) {
                    alert('Se requieren al menos 20 velas para la simulación.');
                    return;
                }

                // Ocultar tabla y limpiar todo el cuerpo visual
                resultadosDiv.style.display = 'none';
                document.body.scrollTop = 0;
                document.documentElement.scrollTop = 0;
                resumenDiv.innerHTML = '<div id="resumen" style="padding:30px;font-family:monospace;"></div>';
                resumenDiv.style.display = 'block';
                toggleTablaButton.style.display = 'inline-block';
                toggleTablaButton.textContent = 'Ver tabla de velas';

                // === MÉTRICAS REALES BASADAS EN EL DATASET CORTADO E INVERTIDO ===

                // Obtener series desde dataset invertido (datosParaCalculo[0] es la vela más reciente)
                const closes = datosParaCalculo.map(v => parseFloat(v[4]));
                const volumenes = datosParaCalculo.map(v => parseFloat(v[5]));
                const takerBuyVolumenes = datosParaCalculo.map(v => parseFloat(v[9]));

                // Calcular métricas principales
                const precioMedio = closes.reduce((a,b)=>a+b,0)/closes.length;
                const emaSerie14 = calcularEMAserie(closes, 14);
                const ema = emaSerie14 ? emaSerie14[closes.length - 1] : precioMedio;
                const asimetria = calcularAsimetria(closes);
                const curtosis = calcularCurtosis(closes);
                
                // La autocorrelación se calcula con un lag de 1 sobre los 480 datos para capturar el patrón de reversión.
                // Aunque el nombre es "Auto Correlación 24h", el cálculo se hace sobre el lookback de 480 puntos.
                const autocorr480 = calcularAutocorrelacion(closes, Math.min(1, closes.length - 1));

                const volumenTotal = volumenes.reduce((a,b)=>a+(Number.isFinite(b)?b:0),0);
                const takerBuyVolumenTotal = takerBuyVolumenes.reduce((a,b)=>a+(Number.isFinite(b)?b:0),0);
                const ratioTaker = volumenTotal > 0 ? takerBuyVolumenTotal / volumenTotal : 0.5;

                // Construir objeto de métricas reales
                const metrics = {
                    "EMA": ema,
                    "Pronóstico Lineal": precioMedio,
                    "Curtosis": curtosis,
                    "Asimetría Precios": asimetria,
                    "Auto Correlación 24h": autocorr480,
                    "Prop Vol Taker Buy / Vol": ratioTaker
                };

                // Ejecutar simulación con el dataset invertido para reflejar el orden visual
                const sim = simularMonteCarlo(datosParaCalculo, metrics);
                const steps = 20;

                // Generar HTML
                const html = `
        <h1>Simulación Monte Carlo (${steps} velas - TF: ${currentTimeframe}) - Lookback: ${datosParaCalculo.length}</h1>
        <p><b>Horizonte total:</b> ${sim.horizonteHoras.toFixed(2)} horas</p>
        <p><b>Precio inicial:</b> ${sim.S0.toFixed(2)} USDT</p>
        <p><b>Precio promedio proyectado:</b> ${sim.promedio.toFixed(2)} USDT</p>
        <p><b>Probabilidad de subida:</b> ${sim.subida.toFixed(2)}%</p>
        <p><b>Probabilidad de bajada:</b> ${sim.bajada.toFixed(2)}%</p>
        <p><b>Intervalo 95%:</b> [${sim.ic95[0].toFixed(2)} ; ${sim.ic95[1].toFixed(2)}]</p>
        <p><b>Value at Risk (95%):</b> ${sim.var95.toFixed(2)} USDT</p>
        <p style="margin-top:10px;color:#666;">
            Esta simulación reemplaza los puntos de entrada tradicionales.
            Los valores reflejan proyecciones probabilísticas sobre el horizonte equivalente.
        </p>
        <button id="exportarPDF">Exportar PDF</button>
    `;
                document.getElementById('resumen').innerHTML = html;

                // Exportar a PDF
                document.getElementById('exportarPDF').addEventListener('click', () => {
                    const contenido = document.getElementById('resumen').innerHTML;
                    const ventana = window.open('', '', 'width=800,height=600');
                    ventana.document.write('<html><head><title>Simulación Monte Carlo</title></head><body>');
                    ventana.document.write(contenido);
                    ventana.document.write('</body></html>');
                    ventana.document.close();
                    ventana.print();
                });
            });

            toggleTablaButton.addEventListener('click', () => {
                if (resultadosDiv.style.display === 'none') {
                    resultadosDiv.style.display = 'block';
                    toggleTablaButton.textContent = 'Ocultar tabla de velas';
                } else {
                    resultadosDiv.style.display = 'none';
                    toggleTablaButton.textContent = 'Ver tabla de velas';
                }
            });
        });
    </script>
</body>
</html>
